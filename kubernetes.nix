{
  config,
  pkgs,
  lib,
  ...
}:
let
  cfg = config.kubernetes;
  settingsFormat = pkgs.formats.json { };

  resourceBody = lib.types.submodule (
    { name, ... }:
    {
      freeformType = settingsFormat.type;
      options = {
        apiVersion = lib.mkOption {
          type = lib.types.nullOr lib.types.str;
          default = null;
          description = "Kubernetes API version. If null, it's inferred from `apiMappings`.";
        };
        kind = lib.mkOption {
          type = lib.types.nullOr lib.types.str;
          default = null;
          description = "Kubernetes resource kind. If null, it's inferred from the attribute path.";
        };
        metadata = lib.mkOption {
          type = lib.types.submodule {
            freeformType = settingsFormat.type;
            options.name = lib.mkOption {
              type = lib.types.str;
              default = name;
            };
          };
          default = { };
          description = "Kubernetes resource metadata.";
        };
      };
    }
  );
in
{
  options.kubernetes = {
    package = lib.mkPackageOption pkgs "kubernetes" { };

    resources = lib.mkOption {
      type = lib.types.attrsOf (lib.types.attrsOf (lib.types.attrsOf resourceBody));
      default = { };
      description = "Kubernetes resources, grouped by namespace, then kind.";
    };

    transformers = lib.mkOption {
      type = lib.types.listOf (lib.types.functionTo lib.types.attrs);
      default = [ ];
      description = "List of functions that transform resource attrsets";
    };

    apiMappings = lib.mkOption {
      type = lib.types.attrsOf lib.types.str;
      default = { };
      example = {
        Cluster = "cluster.x-k8s.io/v1beta1";
        HCloudMachineTemplate = "infrastructure.cluster.x-k8s.io/v1beta1";
        HCloudRemediationTemplate = "infrastructure.cluster.x-k8s.io/v1beta1";
        HelmChartProxy = "addons.cluster.x-k8s.io/v1alpha1";
        HelmReleaseProxy = "addons.cluster.x-k8s.io/v1alpha1";
        HetznerCluster = "infrastructure.cluster.x-k8s.io/v1beta1";
        KubeadmConfigTemplate = "bootstrap.cluster.x-k8s.io/v1beta1";
        KubeadmControlPlane = "controlplane.cluster.x-k8s.io/v1beta1";
        MachineDeployment = "cluster.x-k8s.io/v1beta1";
        MachineHealthCheck = "cluster.x-k8s.io/v1beta1";
      };
      description = "Map of kind to apiVersion. Merged with mappings from `apiMappingFile`.";
    };

    namespacedMappings = lib.mkOption {
      type = lib.types.attrsOf lib.types.bool;
      default = { };
      example = {
        Cluster = "cluster.x-k8s.io/v1beta1";
      };
      description = "If a kind is namespaced or not. Merged with values from `apiMappingFile`.";
    };

    apiMappingFile = lib.mkOption {
      type = lib.types.path;
      default = ./apiResources/v1.33.json;
      description = ''
        A JSON file to extend apiMappings.
        Generated by calling `kubectl api-resources --output=json > mappings.json`
      '';
    };

    generated = lib.mkOption {
      type = settingsFormat.type;
      internal = true;
      description = "The final, generated Kubernetes list object.";
    };
  };

  config.kubernetes = {
    # Get apiMappings from apiMappingFile
    apiMappings =
      let
        data = lib.importJSON cfg.apiMappingFile;
        resourceToAttr = resource: {
          name = resource.kind;
          value =
            if !(resource ? group) || resource.group == "" then
              resource.version
            else
              "${resource.group}/${resource.version}";
        };
      in
      lib.listToAttrs (map resourceToAttr data.resources);

    namespacedMappings =
      let
        data = lib.importJSON config.kubernetes.apiMappingFile;
        resourceToAttr = resource: {
          name = resource.kind;
          value = resource.namespaced;
        };
      in
      lib.listToAttrs (map resourceToAttr data.resources);

    generated = lib.pipe cfg.resources [
      # Remove all nulls
      (lib.filterAttrsRecursive (_: v: v != null))
      # Inject apiVersion, kind, metadata.name and metadata.namespace as appropriate
      (lib.mapAttrs (
        namespace: resourcesByKind:
        lib.mapAttrs (
          kind: resourcesByName:
          lib.mapAttrs (
            name: resourceAttrs:
            # Provide a base set of attributes. `recursiveUpdate` will merge `attrs` on top,
            # so any user-defined values for these fields will take precedence.
            lib.pipe (lib.recursiveUpdate (
              {
                apiVersion =
                  if lib.hasAttr "apiVersion" resourceAttrs then
                    resourceAttrs.apiVersion
                  else if lib.hasAttr kind cfg.apiMappings then
                    cfg.apiMappings.${kind}
                  else
                    builtins.throw ''
                      Resource kind: ${kind} name: ${name} has no apiVersion set and not apiMappings
                      ${builtins.toJSON resourceAttrs}
                    '';
                kind = kind;
                metadata.name = name;
              }
              # Don't add metadata.namespace if the namespace is "none"
              // lib.optionalAttrs (namespace != "none") {
                metadata.namespace = namespace;
              }
            ) resourceAttrs) cfg.transformers
          ) resourcesByName
        ) resourcesByKind
      ))
      # Convert attrset with _namedlist attribute true to lists. This is useful
      # when we want to override things in the Kubernetes containers list for
      # example.
      (lib.walkWithPath lib.kubeAttrsToLists)
      # Convert kubernetes.resources.namespace.kind.name into a list of list resources
      (lib.mapAttrsToList (
        namespace: kinds: lib.mapAttrsToList (kind: names: lib.attrValues names) kinds
      ))
      # Flatten the nested lists
      lib.flatten
    ];
  };
}
