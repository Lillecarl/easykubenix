{ config, lib, ... }:
let
  cfg = config.kubernetes;

  parseApiResources =
    file:
    let
      data = builtins.fromJSON (builtins.readFile file);
      resourceToAttr = resource: {
        name = resource.kind;
        value =
          if !(resource ? group) || resource.group == "" then
            resource.version
          else
            "${resource.group}/${resource.version}";
      };
    in
    lib.listToAttrs (map resourceToAttr data.resources);

  resourceBody = lib.types.submodule (
    { name, ... }:
    {
      freeformType = lib.types.anything;
      options = {
        apiVersion = lib.mkOption {
          type = lib.types.nullOr lib.types.str;
          default = null;
          description = "Kubernetes API version. If null, it's inferred from `apiMappings`.";
        };
        kind = lib.mkOption {
          type = lib.types.nullOr lib.types.str;
          default = null;
          description = "Kubernetes resource kind. If null, it's inferred from the attribute path.";
        };
        metadata = lib.mkOption {
          type = lib.types.submodule {
            freeformType = lib.types.anything;
            options.name = lib.mkOption {
              type = lib.types.str;
              default = name;
            };
          };
          default = { };
          description = "Kubernetes resource metadata.";
        };
      };
    }
  );
in
{
  options.kubernetes = {
    # In your options definition
    resources = lib.mkOption {
      type = lib.types.attrsOf (lib.types.attrsOf (lib.types.attrsOf resourceBody));
      default = { };
      description = "Kubernetes resources, grouped by namespace, then kind.";
    };

    apiMappings = lib.mkOption {
      type = lib.types.attrsOf lib.types.str;
      default = { };
      example = {
        Cluster = "cluster.x-k8s.io/v1beta1";
        HCloudMachineTemplate = "infrastructure.cluster.x-k8s.io/v1beta1";
        HCloudRemediationTemplate = "infrastructure.cluster.x-k8s.io/v1beta1";
        HelmChartProxy = "addons.cluster.x-k8s.io/v1alpha1";
        HelmReleaseProxy = "addons.cluster.x-k8s.io/v1alpha1";
        HetznerCluster = "infrastructure.cluster.x-k8s.io/v1beta1";
        KubeadmConfigTemplate = "bootstrap.cluster.x-k8s.io/v1beta1";
        KubeadmControlPlane = "controlplane.cluster.x-k8s.io/v1beta1";
        MachineDeployment = "cluster.x-k8s.io/v1beta1";
        MachineHealthCheck = "cluster.x-k8s.io/v1beta1";
      };
      description = "Map of Kind to apiVersion. Merged with mappings from `apiMappingFile`.";
    };

    apiMappingFile = lib.mkOption {
      type = lib.types.path;
      default = ./apiResources/v1.33.json;
      description = ''
        A JSON file to extend apiMappings.
        Generated by calling `kubectl api-resources --output=json > mappings.json`
      '';
    };

    generated = lib.mkOption {
      type = lib.types.anything;
      internal = true;
      description = "The final, generated Kubernetes list object.";
    };
  };

  config.kubernetes = {
    # The module system merges this definition with the default and any user-provided values.
    # Values from the file will override the defaults.
    apiMappings = parseApiResources cfg.apiMappingFile;

    generated =
      let
        cleanedResources = lib.filterAttrsRecursive (n: v: v != null) cfg.resources;
        mappedResources = lib.mapAttrs (
          namespace: resourcesByKind:
          lib.mapAttrs (
            kind: resourcesByName:
            lib.mapAttrs (
              name: attrs:
              # Provide a base set of attributes. `recursiveUpdate` will merge `attrs` on top,
              # so any user-defined values for these fields will take precedence.
              lib.recursiveUpdate (
                {
                  apiVersion = cfg.apiMappings.${kind};
                  kind = kind;
                  metadata.name = name;
                }
                // lib.optionalAttrs (namespace != "none") {
                  metadata.namespace = namespace;
                }
              ) attrs
            ) resourcesByName
          ) resourcesByKind
        ) cleanedResources;

        resourceList = lib.flatten (
          lib.mapAttrsToList (
            nsName: kinds: lib.mapAttrsToList (kindName: names: lib.attrValues names) kinds
          ) mappedResources
        );
      in
      resourceList;
  };
}
