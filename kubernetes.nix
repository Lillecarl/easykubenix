{
  config,
  pkgs,
  lib,
  ...
}:
let
  cfg = config.kubernetes;
  settingsFormat = pkgs.formats.json { };

  parseApiResources =
    file:
    let
      data = builtins.fromJSON (builtins.readFile file);
      resourceToAttr = resource: {
        name = resource.kind;
        value =
          if !(resource ? group) || resource.group == "" then
            resource.version
          else
            "${resource.group}/${resource.version}";
      };
    in
    lib.listToAttrs (map resourceToAttr data.resources);

  resourceBody = lib.types.submodule (
    { name, ... }:
    {
      freeformType = settingsFormat.type;
      options = {
        apiVersion = lib.mkOption {
          type = lib.types.nullOr lib.types.str;
          default = null;
          description = "Kubernetes API version. If null, it's inferred from `apiMappings`.";
        };
        kind = lib.mkOption {
          type = lib.types.nullOr lib.types.str;
          default = null;
          description = "Kubernetes resource kind. If null, it's inferred from the attribute path.";
        };
        metadata = lib.mkOption {
          type = lib.types.submodule {
            freeformType = settingsFormat.type;
            options.name = lib.mkOption {
              type = lib.types.str;
              default = name;
            };
          };
          default = { };
          description = "Kubernetes resource metadata.";
        };
      };
    }
  );
in
{
  options.kubernetes = {
    package = lib.mkPackageOption pkgs "kubernetes" { };

    resources = lib.mkOption {
      type = lib.types.attrsOf (lib.types.attrsOf (lib.types.attrsOf resourceBody));
      default = { };
      description = "Kubernetes resources, grouped by namespace, then kind.";
    };

    apiMappings = lib.mkOption {
      type = lib.types.attrsOf lib.types.str;
      default = { };
      example = {
        Cluster = "cluster.x-k8s.io/v1beta1";
        HCloudMachineTemplate = "infrastructure.cluster.x-k8s.io/v1beta1";
        HCloudRemediationTemplate = "infrastructure.cluster.x-k8s.io/v1beta1";
        HelmChartProxy = "addons.cluster.x-k8s.io/v1alpha1";
        HelmReleaseProxy = "addons.cluster.x-k8s.io/v1alpha1";
        HetznerCluster = "infrastructure.cluster.x-k8s.io/v1beta1";
        KubeadmConfigTemplate = "bootstrap.cluster.x-k8s.io/v1beta1";
        KubeadmControlPlane = "controlplane.cluster.x-k8s.io/v1beta1";
        MachineDeployment = "cluster.x-k8s.io/v1beta1";
        MachineHealthCheck = "cluster.x-k8s.io/v1beta1";
      };
      description = "Map of Kind to apiVersion. Merged with mappings from `apiMappingFile`.";
    };

    apiMappingFile = lib.mkOption {
      type = lib.types.path;
      default = ./apiResources/v1.33.json;
      description = ''
        A JSON file to extend apiMappings.
        Generated by calling `kubectl api-resources --output=json > mappings.json`
      '';
    };

    generated = lib.mkOption {
      type = settingsFormat.type;
      internal = true;
      description = "The final, generated Kubernetes list object.";
    };
  };

  config.kubernetes = {
    # Get apiMappings from apiMappingFile
    apiMappings = parseApiResources cfg.apiMappingFile;

    generated = lib.pipe cfg.resources [
      # Remove all nulls
      (lib.filterAttrsRecursive (_: v: v != null))
      # Inject apiVersion, kind, metadata.name and metadata.namespace as appropriate
      (lib.mapAttrs (
        namespace: resourcesByKind:
        lib.mapAttrs (
          kind: resourcesByName:
          lib.mapAttrs (
            name: resourceAttrs:
            # Provide a base set of attributes. `recursiveUpdate` will merge `attrs` on top,
            # so any user-defined values for these fields will take precedence.
            lib.recursiveUpdate (
              {
                apiVersion = cfg.apiMappings.${kind};
                kind = kind;
                metadata.name = name;
              }
              # Don't add metadata.namespace if the namespace is "none"
              // lib.optionalAttrs (namespace != "none") {
                metadata.namespace = namespace;
              }
            ) resourceAttrs
          ) resourcesByName
        ) resourcesByKind
      ))
      # Convert attrset with _namedlist attribute true to lists. This is useful
      # when we want to override things in the Kubernetes containers list for
      # example.
      (lib.walkWithPath lib.kubeAttrsToLists)
      # Convert kubernetes.resources.namespace.kind.name into a list of list resources
      (lib.mapAttrsToList (
        namespace: kinds: lib.mapAttrsToList (kind: names: lib.attrValues names) kinds
      ))
      # Flatten the nested lists
      lib.flatten
    ];
  };
}
